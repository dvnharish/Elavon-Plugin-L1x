import * as vscode from 'vscode';
import { Logger } from '../utils/logger';
// import { CredentialManager, ApiCredentials, ConnectionResult } from '../services/CredentialManager';

export interface CredentialTreeItem {
  id: string;
  label: string;
  type: 'environment' | 'credential' | 'field' | 'audit' | 'status';
  environment?: 'uat' | 'production';
  children?: CredentialTreeItem[];
  value?: string;
  isSecret?: boolean;
  status?: 'connected' | 'disconnected' | 'testing' | 'locked';
  lastTested?: Date;
  credentialId?: string;
}

export class CredentialsPanel implements vscode.TreeDataProvider<CredentialTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<CredentialTreeItem | undefined | null | void> = new vscode.EventEmitter<CredentialTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<CredentialTreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

  // private credentialManager: CredentialManager;
  private treeData: CredentialTreeItem[] = [];


  constructor(private context: vscode.ExtensionContext) {
    // this.credentialManager = new CredentialManager(context, context.secrets);
    this.loadCredentials();
  }

  getTreeItem(element: CredentialTreeItem): vscode.TreeItem {
    const treeItem = new vscode.TreeItem(element.label);
    
    if (element.children && element.children.length > 0) {
      treeItem.collapsibleState = vscode.TreeItemCollapsibleState.Expanded;
    } else {
      treeItem.collapsibleState = vscode.TreeItemCollapsibleState.None;
    }

    // Set icons and context values based on type
    switch (element.type) {
      case 'environment':
        treeItem.iconPath = new vscode.ThemeIcon('server-environment');
        treeItem.contextValue = 'credentialEnvironment';
        break;
      case 'credential':
        treeItem.iconPath = new vscode.ThemeIcon('key');
        treeItem.contextValue = 'credentialSet';
        break;
      case 'field':
        if (element.isSecret) {
          treeItem.iconPath = new vscode.ThemeIcon('lock');
        } else {
          treeItem.iconPath = new vscode.ThemeIcon('symbol-string');
        }
        treeItem.contextValue = 'credentialField';
        break;
      case 'audit':
        treeItem.iconPath = new vscode.ThemeIcon('history');
        treeItem.contextValue = 'auditTrail';
        break;
      case 'status':
        treeItem.iconPath = new vscode.ThemeIcon('info');
        break;
    }

    return treeItem;
  }

  getChildren(element?: CredentialTreeItem): Thenable<CredentialTreeItem[]> {
    if (!element) {
      // Return root items
      return Promise.resolve(this.treeData);
    }
    
    // Return children of the element
    return Promise.resolve(element.children || []);
  }

  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  getParent(element: CredentialTreeItem): vscode.ProviderResult<CredentialTreeItem> {
    return null;
  }

  // Methods for credential management
  async addCredential(environment: 'uat' | 'production'): Promise<void> {
    Logger.buttonClicked(`addCredential-${environment}`);
    
    try {
      if (this.credentialManager.isCredentialManagerLocked()) {
        await this.credentialManager.unlockCredentials();
      }

      // Show input boxes for credential details
      const merchantId = await vscode.window.showInputBox({
        prompt: `Enter Merchant ID for ${environment.toUpperCase()}`,
        placeHolder: 'e.g., MERCHANT123',
        validateInput: (value) => {
          if (!value || value.trim().length === 0) {
            return 'Merchant ID is required';
          }
          if (value.length < 3) {
            return 'Merchant ID must be at least 3 characters';
          }
          return null;
        }
      });

      if (!merchantId) {
        return;
      }

      const apiKey = await vscode.window.showInputBox({
        prompt: `Enter API Key for ${environment.toUpperCase()}`,
        placeHolder: 'e.g., ak_test_1234567890',
        validateInput: (value) => {
          if (!value || value.trim().length === 0) {
            return 'API Key is required';
          }
          if (value.length < 10) {
            return 'API Key must be at least 10 characters';
          }
          return null;
        }
      });

      if (!apiKey) {
        return;
      }

      const apiSecret = await vscode.window.showInputBox({
        prompt: `Enter API Secret for ${environment.toUpperCase()}`,
        password: true,
        placeHolder: 'Enter API Secret (will be hidden)',
        validateInput: (value) => {
          if (!value || value.trim().length === 0) {
            return 'API Secret is required';
          }
          if (value.length < 10) {
            return 'API Secret must be at least 10 characters';
          }
          return null;
        }
      });

      if (!apiSecret) {
        return;
      }

      // Create and store credentials
      const credentials: ApiCredentials = {
        merchantId: merchantId.trim(),
        apiKey: apiKey.trim(),
        apiSecret: apiSecret.trim(),
        environment,
        createdAt: new Date()
      };

      await this.credentialManager.storeCredentials(credentials);
      await this.loadCredentials();
      
      vscode.window.showInformationMessage(`Credentials added for ${environment.toUpperCase()} environment`);

    } catch (error) {
      Logger.error('Failed to add credentials', error as Error);
      vscode.window.showErrorMessage(`Failed to add credentials: ${(error as Error).message}`);
    }
  }

  async deleteCredential(environment: 'uat' | 'production'): Promise<void> {
    Logger.buttonClicked(`deleteCredential-${environment}`);
    
    try {
      const confirm = await vscode.window.showWarningMessage(
        `Are you sure you want to delete the ${environment.toUpperCase()} credentials?`,
        { modal: true },
        'Delete'
      );

      if (confirm === 'Delete') {
        if (this.credentialManager.isCredentialManagerLocked()) {
          await this.credentialManager.unlockCredentials();
        }

        await this.credentialManager.deleteCredentials(environment);
        await this.loadCredentials();
        
        vscode.window.showInformationMessage(`${environment.toUpperCase()} credentials deleted successfully`);
      }
    } catch (error) {
      Logger.error('Failed to delete credentials', error as Error);
      vscode.window.showErrorMessage(`Failed to delete credentials: ${(error as Error).message}`);
    }
  }

  async testConnection(environment: 'uat' | 'production'): Promise<void> {
    Logger.buttonClicked(`testConnection-${environment}`);
    
    try {
      if (this.credentialManager.isCredentialManagerLocked()) {
        await this.credentialManager.unlockCredentials();
      }

      await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: `Testing ${environment.toUpperCase()} connection...`,
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0, message: 'Authenticating...' });
        
        const result: ConnectionResult = await this.credentialManager.testConnection(environment);
        
        progress.report({ increment: 100, message: 'Complete' });
        
        if (result.success) {
          vscode.window.showInformationMessage(
            `${environment.toUpperCase()} connection successful! ` +
            `Response time: ${result.responseTime}ms`
          );
        } else {
          vscode.window.showErrorMessage(
            `${environment.toUpperCase()} connection failed: ${result.error}`
          );
        }

        await this.loadCredentials();
      });

    } catch (error) {
      Logger.error('Connection test failed', error as Error);
      vscode.window.showErrorMessage(`Connection test failed: ${(error as Error).message}`);
    }
  }

  async exportCredentials(environment: 'uat' | 'production'): Promise<void> {
    Logger.buttonClicked(`exportCredentials-${environment}`);
    
    try {
      if (this.credentialManager.isCredentialManagerLocked()) {
        await this.credentialManager.unlockCredentials();
      }

      const passphrase = await vscode.window.showInputBox({
        prompt: 'Enter passphrase for credential export (minimum 8 characters)',
        password: true,
        validateInput: (value) => {
          if (!value || value.length < 8) {
            return 'Passphrase must be at least 8 characters';
          }
          return null;
        }
      });

      if (!passphrase) {
        return;
      }

      const confirmPassphrase = await vscode.window.showInputBox({
        prompt: 'Confirm passphrase',
        password: true,
        validateInput: (value) => {
          if (value !== passphrase) {
            return 'Passphrases do not match';
          }
          return null;
        }
      });

      if (!confirmPassphrase) {
        return;
      }

      const encryptedBundle = await this.credentialManager.exportCredentials(environment, passphrase);
      
      const saveUri = await vscode.window.showSaveDialog({
        defaultUri: vscode.Uri.file(`l1x-credentials-${environment}-${new Date().toISOString().split('T')[0]}.l1x`),
        filters: {
          'L1X Credential Bundle': ['l1x']
        }
      });

      if (saveUri) {
        await vscode.workspace.fs.writeFile(saveUri, Buffer.from(encryptedBundle, 'utf8'));
        vscode.window.showInformationMessage(`Credentials exported to ${saveUri.fsPath}`);
      }

    } catch (error) {
      Logger.error('Failed to export credentials', error as Error);
      vscode.window.showErrorMessage(`Failed to export credentials: ${(error as Error).message}`);
    }
  }

  async importCredentials(): Promise<void> {
    Logger.buttonClicked('importCredentials');
    
    try {
      if (this.credentialManager.isCredentialManagerLocked()) {
        await this.credentialManager.unlockCredentials();
      }

      const fileUri = await vscode.window.showOpenDialog({
        canSelectMany: false,
        openLabel: 'Import Credentials',
        filters: {
          'L1X Credential Bundle': ['l1x']
        }
      });

      if (!fileUri || fileUri.length === 0) {
        return;
      }

      const encryptedBundle = Buffer.from(await vscode.workspace.fs.readFile(fileUri[0])).toString('utf8');
      
      const passphrase = await vscode.window.showInputBox({
        prompt: 'Enter passphrase to decrypt credential bundle',
        password: true
      });

      if (!passphrase) {
        return;
      }

      await this.credentialManager.importCredentials(encryptedBundle, passphrase);
      await this.loadCredentials();
      
      vscode.window.showInformationMessage('Credentials imported successfully');

    } catch (error) {
      Logger.error('Failed to import credentials', error as Error);
      vscode.window.showErrorMessage(`Failed to import credentials: ${(error as Error).message}`);
    }
  }

  async viewAuditTrail(): Promise<void> {
    Logger.buttonClicked('viewAuditTrail');
    
    try {
      const auditTrail = await this.credentialManager.getAuditTrail();
      
      if (auditTrail.length === 0) {
        vscode.window.showInformationMessage('No audit trail entries found');
        return;
      }

      const auditItems = auditTrail.slice(0, 20).map(entry => ({
        label: `${entry.timestamp.toLocaleString()} - ${entry.action} (${entry.environment})`,
        detail: entry.success ? 'Success' : `Failed: ${entry.error}`,
        description: entry.userAgent
      }));

      const selected = await vscode.window.showQuickPick(auditItems, {
        placeHolder: 'Recent credential operations (showing last 20)',
        matchOnDetail: true,
        matchOnDescription: true
      });

    } catch (error) {
      Logger.error('Failed to view audit trail', error as Error);
      vscode.window.showErrorMessage(`Failed to view audit trail: ${(error as Error).message}`);
    }
  }

  private async loadCredentials(): Promise<void> {
    try {
      const treeData: CredentialTreeItem[] = [];

      // Add environments
      for (const environment of ['uat', 'production'] as const) {
        const credentials = await this.credentialManager.getCredentials(environment);
        const envItem: CredentialTreeItem = {
          id: `env-${environment}`,
          label: `${environment.toUpperCase()} Environment`,
          type: 'environment',
          environment,
          children: []
        };

        if (credentials) {
          // Add credential details
          const credentialItem: CredentialTreeItem = {
            id: `cred-${environment}`,
            label: `Merchant: ${credentials.merchantId}`,
            type: 'credential',
            environment,
            children: [
              {
                id: `field-merchant-${environment}`,
                label: `Merchant ID: ${credentials.merchantId}`,
                type: 'field',
                value: credentials.merchantId
              },
              {
                id: `field-apikey-${environment}`,
                label: `API Key: ${credentials.apiKey.substring(0, 8)}***`,
                type: 'field',
                value: credentials.apiKey,
                isSecret: true
              },
              {
                id: `field-secret-${environment}`,
                label: 'API Secret: ••••••••',
                type: 'field',
                value: credentials.apiSecret,
                isSecret: true
              },
              {
                id: `field-created-${environment}`,
                label: `Created: ${credentials.createdAt.toLocaleString()}`,
                type: 'field'
              }
            ]
          };

          if (credentials.lastTested) {
            credentialItem.children!.push({
              id: `field-tested-${environment}`,
              label: `Last Tested: ${credentials.lastTested.toLocaleString()}`,
              type: 'field'
            });
          }

          envItem.children!.push(credentialItem);
        } else {
          // No credentials for this environment
          envItem.children!.push({
            id: `no-cred-${environment}`,
            label: 'No credentials configured',
            type: 'status'
          });
        }
      }

      // Add audit trail section
      const auditTrail = await this.credentialManager.getAuditTrail();
      if (auditTrail.length > 0) {
        const auditItem: CredentialTreeItem = {
          id: 'audit-trail',
          label: `Audit Trail (${auditTrail.length} entries)`,
          type: 'audit',
          children: auditTrail.slice(0, 10).map((entry, index) => ({
            id: `audit-${index}`,
            label: `${entry.timestamp.toLocaleString()} - ${entry.action}`,
            type: 'field',
            value: entry.success ? 'Success' : `Failed: ${entry.error}`
          }))
        };
        treeData.push(auditItem);
      }

      this.treeData = treeData;
      this.refresh();

    } catch (error) {
      Logger.error('Failed to load credentials', error as Error);
      // Show empty tree on error
      this.treeData = [
        {
          id: 'error',
          label: 'Error loading credentials',
          type: 'status'
        }
      ];
      this.refresh();
    }
  }
}