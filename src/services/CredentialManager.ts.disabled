import * as vscode from 'vscode';
import axios, { AxiosResponse } from 'axios';
import * as crypto from 'crypto';
import { Logger } from '../utils/logger';

export interface ApiCredentials {
  merchantId: string;
  apiKey: string;
  apiSecret: string;
  environment: 'uat' | 'production';
  createdAt: Date;
  lastTested?: Date;
}

export interface ConnectionResult {
  success: boolean;
  latency: number;
  error?: string;
  tokenValid: boolean;
  responseTime: number;
  statusCode?: number;
}

export interface CredentialAuditEntry {
  timestamp: Date;
  action: 'created' | 'updated' | 'deleted' | 'tested' | 'exported' | 'imported';
  environment: 'uat' | 'production';
  credentialId: string;
  success: boolean;
  error?: string;
  userAgent: string;
}

export class CredentialManager {
  private static readonly SECRET_KEY_PREFIX = 'l1x.credentials';
  private static readonly AUDIT_KEY = 'l1x.credential.audit';
  private static readonly LOCK_TIMEOUT_KEY = 'l1x.credential.lockTimeout';
  private static readonly DEFAULT_LOCK_TIMEOUT = 5 * 60 * 1000; // 5 minutes

  private lockTimer?: NodeJS.Timeout;
  private isLocked = false;

  constructor(
    private context: vscode.ExtensionContext,
    private secretStorage: vscode.SecretStorage
  ) {
    this.initializeAutoLock();
  }

  private initializeAutoLock(): void {
    const timeout = this.context.globalState.get<number>(CredentialManager.LOCK_TIMEOUT_KEY) || CredentialManager.DEFAULT_LOCK_TIMEOUT;
    this.resetLockTimer(timeout);
  }

  private resetLockTimer(timeout: number): void {
    if (this.lockTimer) {
      clearTimeout(this.lockTimer);
    }
    
    this.lockTimer = setTimeout(() => {
      this.lockCredentials();
    }, timeout);
  }

  async storeCredentials(credentials: ApiCredentials): Promise<void> {
    if (this.isLocked) {
      throw new Error('Credential manager is locked. Please unlock first.');
    }

    try {
      const credentialId = this.generateCredentialId(credentials.environment);
      const encryptedCredentials = this.encryptCredentials(credentials);
      
      await this.secretStorage.store(credentialId, encryptedCredentials);
      
      // Store metadata in global state (without secrets)
      const metadata = {
        merchantId: credentials.merchantId,
        environment: credentials.environment,
        createdAt: credentials.createdAt,
        lastTested: credentials.lastTested
      };
      
      await this.context.globalState.update(`${CredentialManager.SECRET_KEY_PREFIX}.meta.${credentialId}`, metadata);
      
      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'created',
        environment: credentials.environment,
        credentialId,
        success: true,
        userAgent: this.getUserAgent()
      });

      Logger.info(`Credentials stored for ${credentials.environment} environment`);
      this.resetLockTimer(CredentialManager.DEFAULT_LOCK_TIMEOUT);
      
    } catch (error) {
      Logger.error('Failed to store credentials', error as Error);
      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'created',
        environment: credentials.environment,
        credentialId: 'unknown',
        success: false,
        error: (error as Error).message,
        userAgent: this.getUserAgent()
      });
      throw error;
    }
  }

  async getCredentials(environment: 'uat' | 'production'): Promise<ApiCredentials | null> {
    if (this.isLocked) {
      throw new Error('Credential manager is locked. Please unlock first.');
    }

    try {
      const credentialId = this.generateCredentialId(environment);
      const encryptedCredentials = await this.secretStorage.get(credentialId);
      
      if (!encryptedCredentials) {
        return null;
      }

      const credentials = this.decryptCredentials(encryptedCredentials);
      this.resetLockTimer(CredentialManager.DEFAULT_LOCK_TIMEOUT);
      
      return credentials;
    } catch (error) {
      Logger.error('Failed to retrieve credentials', error as Error);
      return null;
    }
  }

  async testConnection(environment: 'uat' | 'production'): Promise<ConnectionResult> {
    const startTime = Date.now();
    
    try {
      const credentials = await this.getCredentials(environment);
      if (!credentials) {
        return {
          success: false,
          latency: 0,
          error: 'No credentials found for environment',
          tokenValid: false,
          responseTime: 0
        };
      }

      // Get authentication token
      const authResult = await this.authenticateWithL1API(credentials);
      if (!authResult.success) {
        return {
          success: false,
          latency: Date.now() - startTime,
          error: authResult.error,
          tokenValid: false,
          responseTime: Date.now() - startTime
        };
      }

      // Test health endpoint
      const healthResult = await this.testHealthEndpoint(credentials, authResult.token!);
      const totalTime = Date.now() - startTime;

      // Update last tested timestamp
      credentials.lastTested = new Date();
      await this.storeCredentials(credentials);

      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'tested',
        environment,
        credentialId: this.generateCredentialId(environment),
        success: healthResult.success,
        error: healthResult.error,
        userAgent: this.getUserAgent()
      });

      return {
        success: healthResult.success,
        latency: totalTime,
        error: healthResult.error,
        tokenValid: authResult.success,
        responseTime: totalTime,
        statusCode: healthResult.statusCode
      };

    } catch (error) {
      const totalTime = Date.now() - startTime;
      Logger.error('Connection test failed', error as Error);
      
      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'tested',
        environment,
        credentialId: this.generateCredentialId(environment),
        success: false,
        error: (error as Error).message,
        userAgent: this.getUserAgent()
      });

      return {
        success: false,
        latency: totalTime,
        error: (error as Error).message,
        tokenValid: false,
        responseTime: totalTime
      };
    }
  }

  async exportCredentials(environment: 'uat' | 'production', passphrase: string): Promise<string> {
    if (this.isLocked) {
      throw new Error('Credential manager is locked. Please unlock first.');
    }

    try {
      const credentials = await this.getCredentials(environment);
      if (!credentials) {
        throw new Error('No credentials found for environment');
      }

      const exportData = {
        version: '1.0',
        environment,
        credentials,
        exportedAt: new Date().toISOString(),
        exportedBy: this.getUserAgent()
      };

      const encryptedBundle = this.encryptWithPassphrase(JSON.stringify(exportData), passphrase);
      
      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'exported',
        environment,
        credentialId: this.generateCredentialId(environment),
        success: true,
        userAgent: this.getUserAgent()
      });

      Logger.info(`Credentials exported for ${environment} environment`);
      return encryptedBundle;

    } catch (error) {
      Logger.error('Failed to export credentials', error as Error);
      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'exported',
        environment,
        credentialId: this.generateCredentialId(environment),
        success: false,
        error: (error as Error).message,
        userAgent: this.getUserAgent()
      });
      throw error;
    }
  }

  async importCredentials(encryptedBundle: string, passphrase: string): Promise<void> {
    if (this.isLocked) {
      throw new Error('Credential manager is locked. Please unlock first.');
    }

    try {
      const decryptedData = this.decryptWithPassphrase(encryptedBundle, passphrase);
      const importData = JSON.parse(decryptedData);

      if (importData.version !== '1.0') {
        throw new Error('Unsupported credential bundle version');
      }

      const credentials: ApiCredentials = importData.credentials;
      await this.storeCredentials(credentials);

      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'imported',
        environment: credentials.environment,
        credentialId: this.generateCredentialId(credentials.environment),
        success: true,
        userAgent: this.getUserAgent()
      });

      Logger.info(`Credentials imported for ${credentials.environment} environment`);

    } catch (error) {
      Logger.error('Failed to import credentials', error as Error);
      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'imported',
        environment: 'uat', // Default since we don't know
        credentialId: 'unknown',
        success: false,
        error: (error as Error).message,
        userAgent: this.getUserAgent()
      });
      throw error;
    }
  }

  async deleteCredentials(environment: 'uat' | 'production'): Promise<void> {
    if (this.isLocked) {
      throw new Error('Credential manager is locked. Please unlock first.');
    }

    try {
      const credentialId = this.generateCredentialId(environment);
      await this.secretStorage.delete(credentialId);
      await this.context.globalState.update(`${CredentialManager.SECRET_KEY_PREFIX}.meta.${credentialId}`, undefined);

      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'deleted',
        environment,
        credentialId,
        success: true,
        userAgent: this.getUserAgent()
      });

      Logger.info(`Credentials deleted for ${environment} environment`);

    } catch (error) {
      Logger.error('Failed to delete credentials', error as Error);
      await this.addAuditEntry({
        timestamp: new Date(),
        action: 'deleted',
        environment,
        credentialId: this.generateCredentialId(environment),
        success: false,
        error: (error as Error).message,
        userAgent: this.getUserAgent()
      });
      throw error;
    }
  }

  lockCredentials(): void {
    this.isLocked = true;
    if (this.lockTimer) {
      clearTimeout(this.lockTimer);
    }
    Logger.info('Credential manager locked due to inactivity');
  }

  async unlockCredentials(): Promise<void> {
    // In a real implementation, this would require user authentication
    this.isLocked = false;
    this.resetLockTimer(CredentialManager.DEFAULT_LOCK_TIMEOUT);
    Logger.info('Credential manager unlocked');
  }

  isCredentialManagerLocked(): boolean {
    return this.isLocked;
  }

  async getAuditTrail(): Promise<CredentialAuditEntry[]> {
    const auditData = this.context.globalState.get<CredentialAuditEntry[]>(CredentialManager.AUDIT_KEY) || [];
    return auditData.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
  }

  private async authenticateWithL1API(credentials: ApiCredentials): Promise<{ success: boolean; token?: string; error?: string }> {
    try {
      const baseUrl = credentials.environment === 'uat' 
        ? 'https://api-uat.elavon.com' 
        : 'https://api.elavon.com';

      const authPayload = {
        merchant_id: credentials.merchantId,
        api_key: credentials.apiKey,
        api_secret: credentials.apiSecret
      };

      const response: AxiosResponse = await axios.post(`${baseUrl}/v1/auth/token`, authPayload, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'L1X-ElavonX-Migrator/1.0'
        }
      });

      if (response.status === 200 && response.data.access_token) {
        return {
          success: true,
          token: response.data.access_token
        };
      } else {
        return {
          success: false,
          error: 'Invalid response from authentication endpoint'
        };
      }

    } catch (error: any) {
      if (error.response) {
        return {
          success: false,
          error: `Authentication failed: ${error.response.status} - ${error.response.data?.message || 'Unknown error'}`
        };
      } else if (error.request) {
        return {
          success: false,
          error: 'Network error: Unable to reach authentication endpoint'
        };
      } else {
        return {
          success: false,
          error: `Authentication error: ${error.message}`
        };
      }
    }
  }

  private async testHealthEndpoint(credentials: ApiCredentials, token: string): Promise<{ success: boolean; error?: string; statusCode?: number }> {
    try {
      const baseUrl = credentials.environment === 'uat' 
        ? 'https://api-uat.elavon.com' 
        : 'https://api.elavon.com';

      const response: AxiosResponse = await axios.get(`${baseUrl}/v1/health`, {
        timeout: 5000,
        headers: {
          'Authorization': `Bearer ${token}`,
          'User-Agent': 'L1X-ElavonX-Migrator/1.0'
        }
      });

      return {
        success: response.status === 200,
        statusCode: response.status
      };

    } catch (error: any) {
      if (error.response) {
        return {
          success: false,
          error: `Health check failed: ${error.response.status}`,
          statusCode: error.response.status
        };
      } else {
        return {
          success: false,
          error: `Health check error: ${error.message}`
        };
      }
    }
  }

  private encryptCredentials(credentials: ApiCredentials): string {
    const key = this.getEncryptionKey();
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher('aes-256-cbc', key);
    
    let encrypted = cipher.update(JSON.stringify(credentials), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return iv.toString('hex') + ':' + encrypted;
  }

  private decryptCredentials(encryptedData: string): ApiCredentials {
    const key = this.getEncryptionKey();
    const parts = encryptedData.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encrypted = parts[1];
    
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }

  private encryptWithPassphrase(data: string, passphrase: string): string {
    const salt = crypto.randomBytes(32);
    const key = crypto.pbkdf2Sync(passphrase, salt, 10000, 32, 'sha256');
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipherGCM('aes-256-gcm', key, iv);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return salt.toString('hex') + ':' + iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
  }

  private decryptWithPassphrase(encryptedData: string, passphrase: string): string {
    const parts = encryptedData.split(':');
    const salt = Buffer.from(parts[0], 'hex');
    const iv = Buffer.from(parts[1], 'hex');
    const authTag = Buffer.from(parts[2], 'hex');
    const encrypted = parts[3];
    
    const key = crypto.pbkdf2Sync(passphrase, salt, 10000, 32, 'sha256');
    
    const decipher = crypto.createDecipherGCM('aes-256-gcm', key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }

  private getEncryptionKey(): string {
    // In a real implementation, this would be more sophisticated
    return crypto.createHash('sha256').update(this.context.extension.id).digest('hex');
  }

  private generateCredentialId(environment: 'uat' | 'production'): string {
    return `${CredentialManager.SECRET_KEY_PREFIX}.${environment}`;
  }

  private getUserAgent(): string {
    return `L1X-ElavonX-Migrator/${this.context.extension.packageJSON.version} VSCode/${vscode.version}`;
  }

  private async addAuditEntry(entry: CredentialAuditEntry): Promise<void> {
    const auditTrail = await this.getAuditTrail();
    auditTrail.unshift(entry);
    
    // Keep only last 100 entries
    const trimmedTrail = auditTrail.slice(0, 100);
    
    await this.context.globalState.update(CredentialManager.AUDIT_KEY, trimmedTrail);
  }

  dispose(): void {
    if (this.lockTimer) {
      clearTimeout(this.lockTimer);
    }
  }
}