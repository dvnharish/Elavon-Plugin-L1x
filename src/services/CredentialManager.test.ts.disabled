import { CredentialManager, ApiCredentials } from './CredentialManager';
import { createMockContext } from '../test/mocks';
import * as vscode from 'vscode';

// Mock axios
jest.mock('axios');
const mockAxios = require('axios');

describe('CredentialManager', () => {
  let credentialManager: CredentialManager;
  let mockContext: vscode.ExtensionContext;
  let mockSecretStorage: vscode.SecretStorage;

  beforeEach(() => {
    mockContext = createMockContext();
    mockSecretStorage = mockContext.secrets;
    credentialManager = new CredentialManager(mockContext, mockSecretStorage);
    jest.clearAllMocks();
  });

  afterEach(() => {
    credentialManager.dispose();
  });

  describe('storeCredentials', () => {
    it('should store credentials successfully', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_123456',
        apiSecret: 'secret_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);

      expect(mockSecretStorage.store).toHaveBeenCalledWith(
        'l1x.credentials.uat',
        expect.any(String)
      );
    });

    it('should throw error when credential manager is locked', async () => {
      credentialManager.lockCredentials();

      const credentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_123456',
        apiSecret: 'secret_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await expect(credentialManager.storeCredentials(credentials))
        .rejects.toThrow('Credential manager is locked');
    });
  });

  describe('getCredentials', () => {
    it('should retrieve credentials successfully', async () => {
      const originalCredentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_123456',
        apiSecret: 'secret_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      // First store credentials
      await credentialManager.storeCredentials(originalCredentials);

      // Then retrieve them
      const retrievedCredentials = await credentialManager.getCredentials('uat');

      expect(retrievedCredentials).toBeTruthy();
      expect(retrievedCredentials?.merchantId).toBe('TEST123');
      expect(retrievedCredentials?.environment).toBe('uat');
    });

    it('should return null when no credentials exist', async () => {
      (mockSecretStorage.get as jest.Mock).mockResolvedValue(undefined);

      const credentials = await credentialManager.getCredentials('production');

      expect(credentials).toBeNull();
    });

    it('should throw error when credential manager is locked', async () => {
      credentialManager.lockCredentials();

      await expect(credentialManager.getCredentials('uat'))
        .rejects.toThrow('Credential manager is locked');
    });
  });

  describe('testConnection', () => {
    it('should test connection successfully', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_123456',
        apiSecret: 'secret_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);

      // Mock successful authentication
      mockAxios.post.mockResolvedValueOnce({
        status: 200,
        data: { access_token: 'mock_token_123' }
      });

      // Mock successful health check
      mockAxios.get.mockResolvedValueOnce({
        status: 200,
        data: { status: 'healthy' }
      });

      const result = await credentialManager.testConnection('uat');

      expect(result.success).toBe(true);
      expect(result.tokenValid).toBe(true);
      expect(result.latency).toBeGreaterThan(0);
    });

    it('should handle authentication failure', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_invalid',
        apiSecret: 'secret_invalid',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);

      // Mock authentication failure
      mockAxios.post.mockRejectedValueOnce({
        response: {
          status: 401,
          data: { message: 'Invalid credentials' }
        }
      });

      const result = await credentialManager.testConnection('uat');

      expect(result.success).toBe(false);
      expect(result.tokenValid).toBe(false);
      expect(result.error).toContain('Authentication failed: 401');
    });

    it('should handle network errors', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_123456',
        apiSecret: 'secret_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);

      // Mock network error
      mockAxios.post.mockRejectedValueOnce({
        request: {},
        message: 'Network Error'
      });

      const result = await credentialManager.testConnection('uat');

      expect(result.success).toBe(false);
      expect(result.error).toContain('Network error');
    });
  });

  describe('exportCredentials', () => {
    it('should export credentials with encryption', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_123456',
        apiSecret: 'secret_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);

      const encryptedBundle = await credentialManager.exportCredentials('uat', 'test_passphrase');

      expect(encryptedBundle).toBeTruthy();
      expect(typeof encryptedBundle).toBe('string');
      expect(encryptedBundle.split(':')).toHaveLength(4); // salt:iv:authTag:encrypted
    });

    it('should throw error for non-existent credentials', async () => {
      await expect(credentialManager.exportCredentials('production', 'test_passphrase'))
        .rejects.toThrow('No credentials found for environment');
    });
  });

  describe('importCredentials', () => {
    it('should import credentials successfully', async () => {
      const originalCredentials: ApiCredentials = {
        merchantId: 'IMPORT123',
        apiKey: 'ak_import_123456',
        apiSecret: 'secret_import_123456',
        environment: 'production',
        createdAt: new Date()
      };

      // First export to get encrypted bundle
      await credentialManager.storeCredentials(originalCredentials);
      const encryptedBundle = await credentialManager.exportCredentials('production', 'import_passphrase');

      // Clear credentials
      await credentialManager.deleteCredentials('production');

      // Import credentials
      await credentialManager.importCredentials(encryptedBundle, 'import_passphrase');

      // Verify import
      const importedCredentials = await credentialManager.getCredentials('production');
      expect(importedCredentials?.merchantId).toBe('IMPORT123');
      expect(importedCredentials?.environment).toBe('production');
    });

    it('should throw error for invalid passphrase', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'TEST123',
        apiKey: 'ak_test_123456',
        apiSecret: 'secret_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);
      const encryptedBundle = await credentialManager.exportCredentials('uat', 'correct_passphrase');

      await expect(credentialManager.importCredentials(encryptedBundle, 'wrong_passphrase'))
        .rejects.toThrow();
    });
  });

  describe('deleteCredentials', () => {
    it('should delete credentials successfully', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'DELETE123',
        apiKey: 'ak_delete_123456',
        apiSecret: 'secret_delete_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);
      await credentialManager.deleteCredentials('uat');

      const retrievedCredentials = await credentialManager.getCredentials('uat');
      expect(retrievedCredentials).toBeNull();
    });
  });

  describe('lock/unlock mechanism', () => {
    it('should lock and unlock credential manager', async () => {
      expect(credentialManager.isCredentialManagerLocked()).toBe(false);

      credentialManager.lockCredentials();
      expect(credentialManager.isCredentialManagerLocked()).toBe(true);

      await credentialManager.unlockCredentials();
      expect(credentialManager.isCredentialManagerLocked()).toBe(false);
    });
  });

  describe('audit trail', () => {
    it('should maintain audit trail for operations', async () => {
      const credentials: ApiCredentials = {
        merchantId: 'AUDIT123',
        apiKey: 'ak_audit_123456',
        apiSecret: 'secret_audit_123456',
        environment: 'uat',
        createdAt: new Date()
      };

      await credentialManager.storeCredentials(credentials);
      await credentialManager.deleteCredentials('uat');

      const auditTrail = await credentialManager.getAuditTrail();
      expect(auditTrail.length).toBeGreaterThan(0);
      
      const createEntry = auditTrail.find(entry => entry.action === 'created');
      const deleteEntry = auditTrail.find(entry => entry.action === 'deleted');
      
      expect(createEntry).toBeTruthy();
      expect(deleteEntry).toBeTruthy();
    });
  });
});